---
sidebar_label: 46.hook
sidebar_position: 45
title: 46.hook
---

## PR #1156

### 问题描述：
在配置容器生命周期时候，我们有 LifeCycle 和 postStart 字段，但是我们一直没有用，这个pr实现了 kubelet 创建容器后能够做些 hook 操作。

### 解决方法：

1. 修改了4个文件
   
![](https://raw.githubusercontent.com/mouuii/picture/master/%E6%88%AA%E5%B1%8F2023-06-22%20%E4%B8%8B%E5%8D%881.53.31.png)

2. 修改 kubelet.go 文件在runContainer函数中判断是否设置了 hook ，如果设置了，执行该hook

![](https://raw.githubusercontent.com/mouuii/picture/master/%E6%88%AA%E5%B1%8F2023-06-22%20%E4%B8%8B%E5%8D%882.00.35.png)

3. 增加 handler.go 实现2个 handler 接口，分别是 exec 和 http hander，这里我们来看下** http handler**

![](https://raw.githubusercontent.com/mouuii/picture/master/%E6%88%AA%E5%B1%8F2023-06-22%20%E4%B8%8B%E5%8D%882.04.54.png)

在 上图代码中，我们会调用 ResolvePort 来匹配端口，这里来复习下这段代码：

```go
// ResolvePort attempts to turn a IntOrString port reference into a concrete port number.
// If portReference has an int value, it is treated as a literal, and simply returns that value.
// If portReference is a string, an attempt is first made to parse it as an integer.  If that fails,
// an attempt is made to find a port with the same name in the container spec.
// If a port with the same name is found, it's ContainerPort value is returned.  If no matching
// port is found, an error is returned.
func ResolvePort(portReference util.IntOrString, container *api.Container) (int, error) {
	if portReference.Kind == util.IntstrInt {
		return portReference.IntVal, nil
	} else {
		portName := portReference.StrVal
		port, err := strconv.Atoi(portName)
		if err == nil {
			return port, nil
		}
		for _, portSpec := range container.Ports {
			if portSpec.Name == portName {
				return portSpec.ContainerPort, nil
			}
		}

	}
	return -1, fmt.Errorf("couldn't find port: %v in %v", portReference, container)
}
```


这段代码是Go语言编写的，它是一个名为ResolvePort的函数，用于将一个整数或字符串形式的端口引用解析为一个具体的端口号。函数接受两个参数：portReference 和 container，并返回一个整数和一个错误对象。

- portReference 是一个 IntOrString 类型的变量，它可以是整数或字符串。这种类型通常用于 Kubernetes 的 API 中，允许用户以整数或字符串的形式提供值。

- container 是一个指向 api.Container 类型的指针，它包含容器的规范，包括容器暴露的端口。

函数的工作流程如下：

a. 首先检查 portReference 的类型。如果它是整数 (portReference.Kind == util.IntstrInt)，那么直接返回这个整数值。在这种情况下，错误对象为 nil。

b. 如果 portReference 是一个字符串，函数首先尝试将它解析为一个整数（通过 strconv.Atoi(portName)）。如果解析成功，返回解析出的整数值和 nil 错误对象。

c. 如果字符串不能被解析为整数，函数会遍历容器规范中定义的所有端口。对于每一个端口，它检查端口的名称是否与 portReference 的字符串值相匹配。如果找到匹配的端口，返回该端口的 ContainerPort 值和 nil 错误对象。

d. 如果 portReference 既不是一个有效的整数，也没有在容器规范中找到匹配的端口名称，函数返回 -1 作为端口号，并返回一个包含错误信息的错误对象。

总的来说，ResolvePort 函数是用来解析可能是整数或字符串的端口引用，并尝试将其转换为一个具体的端口号。如果无法转换，它会返回一个错误。